<?xml version="1.0" encoding="utf-8"?>
<resources>

    <string name="app_name">RxJava-Android-Sample</string>
    <string name="hello_world">Hello world!</string>
    <string name="action_settings">Settings</string>
    <string name="github_oauth_token"><!-- InsertYouroAuthTokenHere --></string>

    <string name="btn_demo_schedulers">bg work (schedulers &amp; concurrency)-调度器,并发性</string>
    <string name="btn_demo_buffer">accumulate calls (buffer)-积累调用(缓冲)</string>
    <string name="btn_demo_debounce">search text listener(debounce)-搜索文本侦听器(防反跳)</string>
    <string name="btn_demo_timeout">Timeout long running jobs-超时长时间运行的作业</string>
    <string name="btn_demo_retrofit">Retrofit + RxJava</string>
    <string name="btn_demo_double_binding_textview">Double binding (PublishSubject)-双绑定(PublishSubject)</string>
    <string name="btn_demo_polling">Polling with RxJava-轮询</string>
    <string name="btn_demo_rxbus">Event Bus with RxJava</string>
    <string name="btn_demo_form_validation_combinel">Form Validation with CombineLatest-使用CombineLatest进行表单验证</string>
    <string name="btn_demo_pseudocache">Pseudo cache using concat-使用concat的伪缓存</string>
    <string name="btn_demo_timing">Variations of timing/intervals/delays-变化的时间间隔/延迟</string>
    <string name="btn_demo_exponential_backoff">Exponential backoff-指数倒扣</string>
    <string name="btn_demo_rotation_persist">Rotation persist-暂时不可点击</string>
    <string name="btn_demo_volley">Volley request demo</string>
    <string name="btn_demo_pagination">Paging example-分页的例子</string>
    <string name="btn_demo_pagination_more">MORE-分页更多</string>
    <string name="btn_demo_networkDetector">Network Detector (Subject)-网络检测器(主题)</string>
    <string name="btn_demo_using">Setup &amp; teardown resources (using)</string>
    <string name="btn_demo_multicastPlayground">MultiConnect operator playground</string>

    <string name="msg_demo_pagination">This is a demo of how you can do a list pagination with Rx. We page 10 items at a time and there are 55 items altogether \n这是一个演示如何使用Rx进行列表分页的示例。我们一次翻页10个条目，总共有55个条目</string>

    <string name="msg_demo_volley">This is a Volley request demo \n这是一个Volley请求演示</string>

    <string name="msg_demo_concurrency_schedulers">This is a demo of how long running operations can be offloaded to a background thread. After the operation is done, we resume back on the main thread. All using RxJava! \n\n To really see this shine. Hit the button multiple times and see how the button click which is a ui operation is never blocked because the long operation only runs in the background \n这是一个演示如何将长时间运行的操作卸载到后台线程。操作完成后，我们回到主线程。所有使用RxJava !\n\n才能真正看到这光芒。多次点击按钮，查看按钮点击的ui操作从来没有被阻塞，因为长操作只在后台运行</string>

    <string name="msg_demo_buffer">This is a demo of how events can be accumulated using the "buffer" operation. Tap the button below repetitively and you will notice in the logs that button taps are collected over a span of 2s and printed below.\n这是一个演示如何使用"buffer"操作累积事件。重复点击下面的按钮，您会注意到在日志中按钮的点击是在2s的跨度内收集的，并打印在下面</string>

    <string name="msg_demo_debounce">As you type in the input box, it will not shoot out log messages at every single input character change, but rather only pick the last one.\n 当您在输入框中键入时，它不会在每次输入字符改变时弹出日志消息，而只是选择最后一个</string>

    <string name="msg_demo_timeout">This is a demo of terminating events, that take too long to process. Events in this demo should timeout in 3 seconds. Button 1 is an event that takes 2s to process, and Button 2 is a n event that takes 5s to process. Hit Button 2, and see in the logs that it\'s been cancelled, while this is not the case for Button \n1.这是一个终止事件的演示，需要很长时间来处理。本演示中的事件应该在3秒内超时。Button 1是一个需要2s处理的事件，Button 2是一个需要5s处理的n个事件。点击按钮2，在日志中看到它已经被取消，而按钮1则不是这样</string>

    <string name="msg_demo_retrofit">Retrofit from Square is a super easy networking helper library. It works really well with RxJava and these are examples taken from Jake Wharton\'s talk at Netflix (see README). Really the only interesting bits here are in the code and logs.  Retrofit from Square\n是一个超级简单的网络助手库。它非常适合RxJava，这些例子摘自Jake Wharton在Netflix的演讲(参见README)。这里唯一有趣的是代码和日志。</string>

    <string name="msg_demo_retrofit_async_task_death">This shows how you can replace an AsyncTask with RxJava. The interesting parts are in the code. \n这显示了如何用RxJava替换异步任务。有趣的部分在代码中</string>

    <string name="msg_demo_doublebinding">Watch how the result gloriously auto-updates <ba></ba>sed on your changing inputs. Using a technique like this, you could achieve the two-way binding in Angular Js, or more efficiently use a pattern like the Presentation View Model. \n观察结果如何光荣地自动更新<ba></ba>sed对您不断变化的输入。使用这样的技术，您可以在Angular Js中实现双向绑定，或者更有效地使用像Presentation View Model这样的模式</string>

    <string name="msg_demo_polling">Demo polling or making a call repeatedly with RxJava.\n\nSimple polling: Notice in the logs how a (simulated) network call is repeatedly made in the background.\n演示轮询或使用RxJava重复调用。简单轮询:注意日志中如何在后台重复进行(模拟)网络调用</string>

    <string name="msg_demo_exponential_backoff">These two examples demonstrate retrying and executing with a delay using an exponential backoff strategy.\n这两个例子演示了使用指数backoff策略进行延迟重试和执行</string>

    <string name="msg_demo_rxbus_1">Tap on the below button and RxBus will listen to the events 点击下面的按钮，RxBus将监听事件</string>

    <string name="msg_demo_form_comb_latest">Monitor the state of multiple observables with the combineLatest operator. Only after all the 3 inputs contain valid entries will the submit button light up \n使用combineLatest操作符监视多个可观察对象的状态。只有在所有3个输入都包含有效条目之后，submit按钮才会点亮</string>

    <string name="msg_demo_timing">BTN 1: run single task once (after 2s complete)\nBTN 2: run task every 1s (start delay of 1s) toggle \nBTN 3: run task every 1s (start immediately) toggle \n BTN 4: run task 5 times every 3s (then complete) \nBTN 5: run task A, pause for sometime, then proceed with Task B  \n  BTN 1:单一的任务运行一次(2秒后完成)\ nBTN 2:运行任务每1 s(启动延迟1 s)切换\ nBTN 3:运行任务每1 s(立即开始)切换\ nBTN 4:运行任务每3 s(然后完成)5次\ nBTN 5:任务运行,暂停一段时间,然后继续任务B </string>

    <string name="msg_demo_rotation_persist">This is an example of starting an Observable and using the result across rotations. There are many ways to do this, we use ViewModels from architecture components \n 这是一个启动可观察到的，并跨旋转使用结果的示例。有很多方法可以做到这一点，我们使用来自架构组件</string>

    <string name="msg_demo_network_detector">This is a demo of how to use Subjects to detect Network connectivity\nToggle your Wifi/Network on or off and notice the logs  这是一个演示如何使用主题来检测网络连接\nToggle您的Wifi/Network on或off和注意日志</string>

    <string name="msg_demo_using">This is a demo of the somewhat unknown operator "using".\n\nYou typically use it for managing setup/teardown of resources. Classic cases are DB connections (like Realm), sockets, locks etc.\n\nTap the button and look at the logcat. Particularly notice how the Realm instance is self-contained. That is, it is auto-disposed right after use. \n这是一个有些未知的操作符"using"的演示。您通常使用它来管理资源的设置/删除。经典的情况是数据库连接(如领域)，套接字，锁等\n\nTap按钮和查看logcat。请特别注意领域实例是如何自包含的。也就是说，它在使用后会自动处理
</string>

    <string name="msg_demo_multicast_publishRefCount">RefCount starts the upstream right away and gets disposed off, when all subscribers stop. Hit S1, Hit S2, Hit S1, Hit S2. Hit S1/S2 now and notice the stream starts all over.\n RefCount立即启动上游并被释放。打S1，打S2，打S1，打S2。点击S1/S2，注意到流从头开始。</string>

    <string name="msg_demo_multicast_publishAutoConnect">AutoConnect(2) waits for a min. subscriber count, before starting the upstream. Hit S1 (notice events don\'t start), Hit S2 (notice events now start), Hit S1 (notice that unsubscribing doesn\'t affect upstream), Hit S2, wait for sometime and hit S1 again (notice source stream doesn\'t restart) \n AutoConnect(2)在启动上游之前等待最小订阅方计数。点击S1(注意事件没有开始)，点击S2(注意事件现在开始)，点击S1(注意取消订阅不会影响上游)，点击S2，等待一段时间，再次点击S1(注意源流没有重新启动)</string>

    <string name="msg_demo_multicast_replayAutoConnect">Replay caches the last item. Hit S1, Hit S2, event starts, Hit S2, wait a bit, Hit S2 again (notice it starts with the last item that S1 saw - courtesy Replay). Hit S2, Hit S1, wait a bit. Hit S1 again (notice event upstream continues and doesn\'t restart) \n 重播缓存最后一项。按S1，按S2，事件开始，按S2，稍等，再次按S2(注意，它从S1看到的最后一项开始——礼貌的重播)。按S2，按S1，等等。再次按S1(注意上游的事件继续并且没有重新启动)</string>

    <string name="msg_demo_multicast_replayRefCount">Replay caches the last item. Hit S1, wait a bit, then hit S2 (notice S2 starts immediately with last item that S1 saw), Hit S2, Hit S1. Hit S1/S2 again (notice the stream restarts all over. Interestingly cached last item also removed when both subscribers released) \n 重播缓存最后一项。按S1，稍等，然后按S2(注意S2立即从S1看到的最后一项开始)，按S2，按S1。再次点击S1/S2(注意流将重新启动。有趣的是，缓存的最后一项也删除时，两个订户释放)</string>

    <string name="msg_demo_multicast_replayingShare">Courtesy: new #AndroidDev on the block - JakeWharton. exactly like replay(1).refCount(), but caches the last item even when upstream has been disposed off/released. Hit S1, Hit S2, Hit S1, Hit S2 (notice observable is disposed). Hit S1/S2 again (notice we start with last item emitted) \n Courtesy: new #AndroidDev on the block - JakeWharton. \n 与重播(1). refcount()完全相同，但是即使在上游已经被丢弃/释放时也会缓存最后一项。命中S1，命中S2，命中S1，命中S2(注意，可观察的被丢弃)。再次点击S1/S2(注意，我们从发出的最后一项开始)</string>

    <string name="msg_pseudoCache_demoInfo_concat">Concat merges the results sequentially. But notice that the latter subscription starts only AFTER the first one completes. Some unnecessary waiting there. \n Concat按顺序合并结果。但是请注意，后者仅在第一个订阅完成后才开始。一些不必要的等待在那里。</string>

    <string name="msg_pseudoCache_demoInfo_concatEager">Concat eager is cooler. Both subscriptions start at the same time (parallely) but the order of emission is respected. \n Concat eager更酷。两个订阅同时启动(并行地)，但发射顺序是受尊重的</string>

    <string name="msg_pseudoCache_demoInfo_merge">Merge presents the result as they come in which is great if the disk is *always* faster. If not, you have problems. \n Merge在出现时显示结果，如果磁盘“总是”更快，则效果非常好。如果没有，您就有问题了</string>

    <string name="msg_pseudoCache_demoInfo_mergeSlowDisk">Here\'s a fake example where the disk is made slower than the network call. You can see the results are whack. \n 这里是一个伪示例，其中磁盘比网络调用慢。您可以看到结果是whack.</string>

    <string name="msg_pseudoCache_demoInfo_mergeOptimized">This is an optimized merge and probably want to use. Notice subscriptions happen immediately and network results are respected regardless of when they come in. So if the disk is slower, it is discarded. \n 这是一个优化的合并，可能需要使用。通知订阅立即发生，网络结果受到尊重，不管它们什么时候出现。所以如果磁盘变慢了，它就会被丢弃</string>

    <string name="msg_pseudoCache_demoInfo_mergeOptimizedSlowDisk">Similar to optimized merge (same code). Notice though that if the disk is slower it\'s discarded in favor of the "fresh" network data which in this case happens to be faster. \n 类似于优化合并(相同代码)。请注意，如果磁盘变慢了，它就会被丢弃，取而代之的是“新的”网络数据，在这种情况下，网络数据碰巧更快</string>

    <string name="tap_me">tap me</string>

    <string name="start_long_operation">Start long operation</string>

    <string name="enter_some_search_text">Enter some search text</string>
    <string name="btn_1">BTN 1</string>
    <string name="btn_2">BTN 2</string>
    <string name="btn_3">BTN 3</string>
    <string name="btn_4">BTN 4</string>
    <string name="btn_5">BTN 5</string>
    <string name="clear_log">CLEAR LOG</string>
    <string name="one_hundred">100</string>
    <string name="plus">+</string>
    <string name="eight">8</string>
    <string name="zero">0</string>
    <string name="retry">Retry</string>
    <string name="delay">Delay</string>
    <string name="enter_a_valid_email_below">Enter a valid email below:</string>
    <string name="password_than_8_chrs"><![CDATA[password (> than 8 chrs):]]></string>
    <string name="number_between_1_amp_100"><![CDATA[number (between 1 & 100):]]></string>
    <string name="submit">Submit</string>
    <string name="start_simple_polling">Start simple polling</string>
    <string name="start_increasingly_delayed_polling">Start increasingly delayed polling</string>
    <string name="info_about_the_demo_will_show_up_here">Info about the demo will show up here</string>
    <string name="concat">concat</string>
    <string name="concat_eager">concat (eager)</string>
    <string name="merge">merge</string>
    <string name="merge_n_slower_disk">merge (slower disk)</string>
    <string name="merge_n_optimized">merge (optimized)</string>
    <string name="merge_n_optimized_slow_disk">merge (optimized) slow disk</string>
    <string name="start_disk_network_call"><![CDATA[Start disk > network call]]></string>
    <string name="log_contributors_of">Log contributors of:</string>
    <string name="square">square</string>
    <string name="owner">owner</string>
    <string name="retrofit">retrofit</string>
    <string name="reponame">reponame</string>
    <string name="log_with_full_user_info">Log with full User Info:</string>
    <string name="log_user_info">Log User Info:</string>
    <string name="kaushikgopal">kaushikgopal</string>
    <string name="start_operation">Start operation</string>
    <string name="one">1</string>
    <string name="tap">tap!</string>
    <string name="button_1">Button 1</string>
    <string name="button_2">Button 2</string>
    <string name="start">Start</string>
    <string name="i_amz_btn">I AMZ BTN</string>

</resources>
